{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the StrangeScout docs \u00b6 What is StrangeScout? \u00b6 StrangeScout is the one-of-a-kind scouting system developed for FRC (FIRST Robotics Competition) teams. FIRST is a multinational organization designed to give students through high school hands on learning experiences in STEAM fields, by providing them with challenging and engaging competitions to construct robots and compete with them. A key element of any FRC event is scouting, where teams will track the capabilities of other team's robots to help determine their play strategy and who they may ally with later in the event. This is where StrangeScout comes in. How it works \u00b6 StrangeScout is built with a unique approach to scouting. While the traditional method involves a checklist or similar method where scouts count individual occurrences of a wide variety of potential events, StrangeScout uses a journaling method. For example, if the current game involves picking up balls and placing them into a box, the scouters will only be presented with a single button: \"pick up a ball\". When the robot they're tracking picks up a ball they click this button. Then, a new dialog will appear presenting them with a list of options where the ball may go, which they will then choose when the robot places the ball in that location. This system allows for precise tracing of robots actions, while maintaining simplicity and ease of usability for the actual scouters. Getting started \u00b6 To setup and begin using StrangeScout, you can follow our Installation Guide . If you'd like to take a look at our code, it can be found at the following locations: Frontend Application Code Backend API Code Build and Deployment Scripts The source files for this documentation can be found here: StrangeScout Docs Source Detailed documentation of the available API endpoints can also be found in this documentation: Authentication Routes","title":"Home"},{"location":"#welcome-to-the-strangescout-docs","text":"","title":"Welcome to the StrangeScout docs"},{"location":"#what-is-strangescout","text":"StrangeScout is the one-of-a-kind scouting system developed for FRC (FIRST Robotics Competition) teams. FIRST is a multinational organization designed to give students through high school hands on learning experiences in STEAM fields, by providing them with challenging and engaging competitions to construct robots and compete with them. A key element of any FRC event is scouting, where teams will track the capabilities of other team's robots to help determine their play strategy and who they may ally with later in the event. This is where StrangeScout comes in.","title":"What is StrangeScout?"},{"location":"#how-it-works","text":"StrangeScout is built with a unique approach to scouting. While the traditional method involves a checklist or similar method where scouts count individual occurrences of a wide variety of potential events, StrangeScout uses a journaling method. For example, if the current game involves picking up balls and placing them into a box, the scouters will only be presented with a single button: \"pick up a ball\". When the robot they're tracking picks up a ball they click this button. Then, a new dialog will appear presenting them with a list of options where the ball may go, which they will then choose when the robot places the ball in that location. This system allows for precise tracing of robots actions, while maintaining simplicity and ease of usability for the actual scouters.","title":"How it works"},{"location":"#getting-started","text":"To setup and begin using StrangeScout, you can follow our Installation Guide . If you'd like to take a look at our code, it can be found at the following locations: Frontend Application Code Backend API Code Build and Deployment Scripts The source files for this documentation can be found here: StrangeScout Docs Source Detailed documentation of the available API endpoints can also be found in this documentation: Authentication Routes","title":"Getting started"},{"location":"installation-guide/","text":"Before you install \u00b6 The following installation guide will document setup with Docker because it's what we at Team 1533 Triple Strange and The Red Alliance use. It's also important to note that StrangeScout is designed to be run behind a reverse proxy, and as such does not have built-in support for HTTPS certificates. We do provide example configurations using the traefik reverse proxy , but you are more than welcome to use your own reverse proxy, or even fork the code and roll in your own support for HTTPS. Dependencies \u00b6 StrangeScout only has two true dependencies: Docker Docker Compose Docker is the program that allows services to be run as individual containers on a host machine, and Docker Compose is a utility that simplifies choreography of multiple docker containers. You will also need to have a domain pointing at the server you're installing StrangeScout on. First, install Docker following the available installation instructions for your distribution of choice, for example on an x86_64 Ubuntu server you would run the following (as root): official instructions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash # update package lists apt-get update # install packages to add repositories apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common # add the docker GPG key curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - # add the docker x86_64 repository add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $( lsb_release -cs ) \\ stable\" # update package lists apt-get update # install docker packages apt-get install docker-ce docker-ce-cli containerd.io Secondly, install Docker Compose following the available installation instructions for your distribution of choice, for example on a *nix server you would run the following (as root): official instructions 1 2 3 4 5 6 7 #!/bin/bash # save the docker-compose script to the bin curl -L \"https://github.com/docker/compose/releases/download/1.25.0/docker-compose- $( uname -s ) - $( uname -m ) \" -o /usr/local/bin/docker-compose # make it executable chmod +x /usr/local/bin/docker-compose After both dependencies have been installed, ensure the Docker system service has been started and enabled: 1 2 systemctl start docker systemctl enable docker Setting up the reverse proxy \u00b6 Now that all dependencies have been installed we can begin setting up traefik for our reverse proxy. For the sake of organization and due to the way docker-compose names containers, you should make a directory to store the reverse proxy files. Run the following two commands before continuing to setup the reverse proxy: 1 2 mkdir -v reverse-proxy cd reverse-proxy Creating a docker network \u00b6 The first step to setting up traefik is to create a new docker network: 1 docker network create strangescout_main This will allow for containers on the same network to easily communicate with each other. In our case it allows for the StrangeScout server to communicate with the database in its own separate container. Creating the certificate file \u00b6 Any modern website should be served using the HTTPS protocol. This ensures any data sent to or from the users is encrypted and cannot be read by unauthorized persons. Our reverse proxy, traefik, has built in support for HTTPS, and can automatically update certificates for HTTPS using ACME (Automated Certificate Management Environment). To do so, we need somewhere to store these certificates. Create a file with the following command as root: 1 touch acme.json Note In order for traefik to store certificates in this file, it must be owned by root. When creating the file, ensure you're running the command as root or using sudo! In order to work properly, we need to set specific permissions on this file. It must ONLY be readable and writable by root. Update the files permissions with the following command as root: 1 chmod 600 acme.json Note chmod is used to update file attributes. In this case, we're setting the file permissions to 600, which corresponds to R/W for the owner, and no permissions for anyone else. Because the file is owned by root, only root can access the file. If these permissions are not set traefik will not be able to get certificates. Creating the compose file \u00b6 Now that our network and ACME certificate file have been created, we can put together the docker-compose file for the reverse proxy. To start, we need to create our compose file: 1 touch docker-compose.yml Now that we have our compose file, let's start with some basic options: 1 2 3 4 5 6 7 8 9 10 # docker-compose.yml version : '3.3' services : reverse-proxy : image : traefik:v2.0 container_name : reverse-proxy hostname : reverse-proxy restart : always What we're doing here is start off by stating that we're using version 3.3 of the docker-compose syntax. Next we start our list of services, and define a service with the name reverse-proxy . Within the reverse-proxy service we specify that it should use the traefik:v2.0 image from Docker Hub, that the container name should be reverse-proxy , the hostname should be reverse-proxy , and the container should always restart if it fails. Note the hostname key sets friendly names that containers can be accessed by on the docker network we created earlier. While this isn't necessary for the reverse proxy container, it will be useful later when we want to specify the url to access the database at. Next, we'll add some command line options that will be given to traefik when it runs: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # docker-compose.yml version : '3.3' services : reverse-proxy : image : traefik:v2.0 container_name : reverse-proxy hostname : reverse-proxy restart : always command : - --providers.docker - --entrypoints.web.address=:80 - --entrypoints.websecure.address=:443 - --entrypoints.mongodb.address=:27017 - --certificatesresolvers.leresolver.acme.caserver=https://acme-v02.api.letsencrypt.org/directory - --certificatesresolvers.leresolver.acme.email=<youremail@yourdomain.tld> - --certificatesresolvers.leresolver.acme.storage=/acme.json - --certificatesresolvers.leresolver.acme.tlschallenge=true --providers.docker tells traefik we have services running via docker --entrypoints.web.address=:80 : Sets the port on the entrypoint named web to port 80 --entrypoints.websecure.address=:443 sets the port on the entrypoint named websecure to port 443 --entrypoints.mongodb.address=:27017 sets the port on the entrypoint named mongodb to port 27017 --certificatesresolvers.leresolver.acme.caserver=https://acme-v02.api.letsencrypt.org/directory sets the URL of the ca server to use for ACME certificates --certificatesresolvers.leresolver.acme.email=<youremail@yourdomain.tld> sets the email used when acquiring certificates --certificatesresolvers.leresolver.acme.storage=/acme.json tells traefik where to store certificates --certificatesresolvers.leresolver.acme.tlschallenge=true tells traefik what method to use to get certificates Note Entrypoints are points where network traffic can enter traefik to be routed. The web entrypoint will be used for unencrypted HTTP traffic (we'll be setting it up to automatically redirect to HTTPS as well), the websecure entrypoint for encrypted HTTPS traffic, and the mongodb entrypoint for direct access to our database. Next we need to open the ports that we defined in our traefik entrypoints: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # docker-compose.yml version : '3.3' services : reverse-proxy : image : traefik:v2.0 container_name : reverse-proxy hostname : reverse-proxy restart : always command : - --providers.docker - --entrypoints.web.address=:80 - --entrypoints.websecure.address=:443 - --entrypoints.mongodb.address=:27017 - --certificatesresolvers.leresolver.acme.caserver=https://acme-v02.api.letsencrypt.org/directory - --certificatesresolvers.leresolver.acme.email=<youremail@yourdomain.tld> - --certificatesresolvers.leresolver.acme.storage=/acme.json - --certificatesresolvers.leresolver.acme.tlschallenge=true ports : - '80:80' - '443:443' - '27017:27017' Each port definition has two parts, separated by a : colon. The first part describes the port to map to on the host machine, while the second part is the port to bind to within the container. For example, 80:80 means that requests to port 80 on the host machine will route to port 80 within the container. In our case we are routing ports 80, 443, and 27017 on the host machine to those same ports within the traefik container. Note Port definitions can also be more specific, including a specific interface they should listen to. For example, 127.0.0.1:80:80 would only map traffic on port 80 from localhost to the container. The next step is to setup some volumes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # docker-compose.yml version : '3.3' services : reverse-proxy : image : traefik:v2.0 container_name : reverse-proxy hostname : reverse-proxy restart : always command : - --providers.docker - --entrypoints.web.address=:80 - --entrypoints.websecure.address=:443 - --entrypoints.mongodb.address=:27017 - --certificatesresolvers.leresolver.acme.caserver=https://acme-v02.api.letsencrypt.org/directory - --certificatesresolvers.leresolver.acme.email=<youremail@yourdomain.tld> - --certificatesresolvers.leresolver.acme.storage=/acme.json - --certificatesresolvers.leresolver.acme.tlschallenge=true ports : - '80:80' - '443:443' - '27017:27017' volumes : - \"./acme.json:/acme.json\" - \"/var/run/docker.sock:/var/run/docker.sock:ro\" Here we are defining two volumes for the container. \"./acme.json:/acme.json\" mounts our ACME certificate file to /acme.json in the container, which is where we've told traefik to look for it \"/var/run/docker.sock:/var/run/docker.sock:ro\" mounts our host machine's docker socket read-only inside the container Mounting the docker socket in the container allows traefik to find out which containers it needs to connect to and what traffic to route to them. Next we need to set some labels on the container, which will be used to configure some additional features: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # docker-compose.yml version : '3.3' services : reverse-proxy : image : traefik:v2.0 container_name : reverse-proxy hostname : reverse-proxy restart : always command : - --providers.docker - --entrypoints.web.address=:80 - --entrypoints.websecure.address=:443 - --entrypoints.mongodb.address=:27017 - --certificatesresolvers.leresolver.acme.caserver=https://acme-v02.api.letsencrypt.org/directory - --certificatesresolvers.leresolver.acme.email=<youremail@yourdomain.tld> - --certificatesresolvers.leresolver.acme.storage=/acme.json - --certificatesresolvers.leresolver.acme.tlschallenge=true ports : - '80:80' - '443:443' - '27017:27017' volumes : - \"./acme.json:/acme.json\" - \"/var/run/docker.sock:/var/run/docker.sock:ro\" labels : - traefik.http.middlewares.compress.compress=true - traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https - traefik.http.routers.redirs.rule=hostregexp(`{host:.+}`) - traefik.http.routers.redirs.entrypoints=web - traefik.http.routers.redirs.middlewares=redirect-to-https traefik.http.middlewares.compress.compress=true creates a new traefik middleware called compress that compresses traffic traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https creates a middleware that redirects traffic to HTTPS traefik.http.routers.redirs.rule=hostregexp(`{host:.+}`) creates a router that matches to all domains traefik.http.routers.redirs.entrypoints=web sets the router to listen on the HTTP web entrypoint traefik.http.routers.redirs.middlewares=redirect-to-https enables the HTTPS redirection middleware Essentially, these labels enable compression on web traffic and automatically redirect any HTTP traffic to HTTPS. Finally, we can add our docker network: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 # docker-compose.yml version : '3.3' services : reverse-proxy : image : traefik:v2.0 container_name : reverse-proxy hostname : reverse-proxy restart : always command : - --providers.docker - --entrypoints.web.address=:80 - --entrypoints.websecure.address=:443 - --entrypoints.mongodb.address=:27017 - --certificatesresolvers.leresolver.acme.caserver=https://acme-v02.api.letsencrypt.org/directory - --certificatesresolvers.leresolver.acme.email=<youremail@yourdomain.tld> - --certificatesresolvers.leresolver.acme.storage=/acme.json - --certificatesresolvers.leresolver.acme.tlschallenge=true ports : - '80:80' - '443:443' - '27017:27017' volumes : - \"./acme.json:/acme.json\" - \"/var/run/docker.sock:/var/run/docker.sock:ro\" labels : - traefik.http.middlewares.compress.compress=true - traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https - traefik.http.routers.redirs.rule=hostregexp(`{host:.+}`) - traefik.http.routers.redirs.entrypoints=web - traefik.http.routers.redirs.middlewares=redirect-to-https networks : - strangescout_main networks : strangescout_main : external : true There are two parts to adding the network. First, we tell our reverse-proxy service to attach to the strangescout_main network, then we define the network in the top level of the compose file. Starting the reverse proxy \u00b6 To start the reverse proxy you only need to run one command: 1 docker-compose up -d As long as you're in the same directory as the docker-compose.yml file, it will automatically be read and the service will start up and fork to the background thanks to the -d flag!","title":"Installation Guide"},{"location":"installation-guide/#before-you-install","text":"The following installation guide will document setup with Docker because it's what we at Team 1533 Triple Strange and The Red Alliance use. It's also important to note that StrangeScout is designed to be run behind a reverse proxy, and as such does not have built-in support for HTTPS certificates. We do provide example configurations using the traefik reverse proxy , but you are more than welcome to use your own reverse proxy, or even fork the code and roll in your own support for HTTPS.","title":"Before you install"},{"location":"installation-guide/#dependencies","text":"StrangeScout only has two true dependencies: Docker Docker Compose Docker is the program that allows services to be run as individual containers on a host machine, and Docker Compose is a utility that simplifies choreography of multiple docker containers. You will also need to have a domain pointing at the server you're installing StrangeScout on. First, install Docker following the available installation instructions for your distribution of choice, for example on an x86_64 Ubuntu server you would run the following (as root): official instructions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash # update package lists apt-get update # install packages to add repositories apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common # add the docker GPG key curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - # add the docker x86_64 repository add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $( lsb_release -cs ) \\ stable\" # update package lists apt-get update # install docker packages apt-get install docker-ce docker-ce-cli containerd.io Secondly, install Docker Compose following the available installation instructions for your distribution of choice, for example on a *nix server you would run the following (as root): official instructions 1 2 3 4 5 6 7 #!/bin/bash # save the docker-compose script to the bin curl -L \"https://github.com/docker/compose/releases/download/1.25.0/docker-compose- $( uname -s ) - $( uname -m ) \" -o /usr/local/bin/docker-compose # make it executable chmod +x /usr/local/bin/docker-compose After both dependencies have been installed, ensure the Docker system service has been started and enabled: 1 2 systemctl start docker systemctl enable docker","title":"Dependencies"},{"location":"installation-guide/#setting-up-the-reverse-proxy","text":"Now that all dependencies have been installed we can begin setting up traefik for our reverse proxy. For the sake of organization and due to the way docker-compose names containers, you should make a directory to store the reverse proxy files. Run the following two commands before continuing to setup the reverse proxy: 1 2 mkdir -v reverse-proxy cd reverse-proxy","title":"Setting up the reverse proxy"},{"location":"installation-guide/#creating-a-docker-network","text":"The first step to setting up traefik is to create a new docker network: 1 docker network create strangescout_main This will allow for containers on the same network to easily communicate with each other. In our case it allows for the StrangeScout server to communicate with the database in its own separate container.","title":"Creating a docker network"},{"location":"installation-guide/#creating-the-certificate-file","text":"Any modern website should be served using the HTTPS protocol. This ensures any data sent to or from the users is encrypted and cannot be read by unauthorized persons. Our reverse proxy, traefik, has built in support for HTTPS, and can automatically update certificates for HTTPS using ACME (Automated Certificate Management Environment). To do so, we need somewhere to store these certificates. Create a file with the following command as root: 1 touch acme.json Note In order for traefik to store certificates in this file, it must be owned by root. When creating the file, ensure you're running the command as root or using sudo! In order to work properly, we need to set specific permissions on this file. It must ONLY be readable and writable by root. Update the files permissions with the following command as root: 1 chmod 600 acme.json Note chmod is used to update file attributes. In this case, we're setting the file permissions to 600, which corresponds to R/W for the owner, and no permissions for anyone else. Because the file is owned by root, only root can access the file. If these permissions are not set traefik will not be able to get certificates.","title":"Creating the certificate file"},{"location":"installation-guide/#creating-the-compose-file","text":"Now that our network and ACME certificate file have been created, we can put together the docker-compose file for the reverse proxy. To start, we need to create our compose file: 1 touch docker-compose.yml Now that we have our compose file, let's start with some basic options: 1 2 3 4 5 6 7 8 9 10 # docker-compose.yml version : '3.3' services : reverse-proxy : image : traefik:v2.0 container_name : reverse-proxy hostname : reverse-proxy restart : always What we're doing here is start off by stating that we're using version 3.3 of the docker-compose syntax. Next we start our list of services, and define a service with the name reverse-proxy . Within the reverse-proxy service we specify that it should use the traefik:v2.0 image from Docker Hub, that the container name should be reverse-proxy , the hostname should be reverse-proxy , and the container should always restart if it fails. Note the hostname key sets friendly names that containers can be accessed by on the docker network we created earlier. While this isn't necessary for the reverse proxy container, it will be useful later when we want to specify the url to access the database at. Next, we'll add some command line options that will be given to traefik when it runs: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # docker-compose.yml version : '3.3' services : reverse-proxy : image : traefik:v2.0 container_name : reverse-proxy hostname : reverse-proxy restart : always command : - --providers.docker - --entrypoints.web.address=:80 - --entrypoints.websecure.address=:443 - --entrypoints.mongodb.address=:27017 - --certificatesresolvers.leresolver.acme.caserver=https://acme-v02.api.letsencrypt.org/directory - --certificatesresolvers.leresolver.acme.email=<youremail@yourdomain.tld> - --certificatesresolvers.leresolver.acme.storage=/acme.json - --certificatesresolvers.leresolver.acme.tlschallenge=true --providers.docker tells traefik we have services running via docker --entrypoints.web.address=:80 : Sets the port on the entrypoint named web to port 80 --entrypoints.websecure.address=:443 sets the port on the entrypoint named websecure to port 443 --entrypoints.mongodb.address=:27017 sets the port on the entrypoint named mongodb to port 27017 --certificatesresolvers.leresolver.acme.caserver=https://acme-v02.api.letsencrypt.org/directory sets the URL of the ca server to use for ACME certificates --certificatesresolvers.leresolver.acme.email=<youremail@yourdomain.tld> sets the email used when acquiring certificates --certificatesresolvers.leresolver.acme.storage=/acme.json tells traefik where to store certificates --certificatesresolvers.leresolver.acme.tlschallenge=true tells traefik what method to use to get certificates Note Entrypoints are points where network traffic can enter traefik to be routed. The web entrypoint will be used for unencrypted HTTP traffic (we'll be setting it up to automatically redirect to HTTPS as well), the websecure entrypoint for encrypted HTTPS traffic, and the mongodb entrypoint for direct access to our database. Next we need to open the ports that we defined in our traefik entrypoints: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # docker-compose.yml version : '3.3' services : reverse-proxy : image : traefik:v2.0 container_name : reverse-proxy hostname : reverse-proxy restart : always command : - --providers.docker - --entrypoints.web.address=:80 - --entrypoints.websecure.address=:443 - --entrypoints.mongodb.address=:27017 - --certificatesresolvers.leresolver.acme.caserver=https://acme-v02.api.letsencrypt.org/directory - --certificatesresolvers.leresolver.acme.email=<youremail@yourdomain.tld> - --certificatesresolvers.leresolver.acme.storage=/acme.json - --certificatesresolvers.leresolver.acme.tlschallenge=true ports : - '80:80' - '443:443' - '27017:27017' Each port definition has two parts, separated by a : colon. The first part describes the port to map to on the host machine, while the second part is the port to bind to within the container. For example, 80:80 means that requests to port 80 on the host machine will route to port 80 within the container. In our case we are routing ports 80, 443, and 27017 on the host machine to those same ports within the traefik container. Note Port definitions can also be more specific, including a specific interface they should listen to. For example, 127.0.0.1:80:80 would only map traffic on port 80 from localhost to the container. The next step is to setup some volumes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # docker-compose.yml version : '3.3' services : reverse-proxy : image : traefik:v2.0 container_name : reverse-proxy hostname : reverse-proxy restart : always command : - --providers.docker - --entrypoints.web.address=:80 - --entrypoints.websecure.address=:443 - --entrypoints.mongodb.address=:27017 - --certificatesresolvers.leresolver.acme.caserver=https://acme-v02.api.letsencrypt.org/directory - --certificatesresolvers.leresolver.acme.email=<youremail@yourdomain.tld> - --certificatesresolvers.leresolver.acme.storage=/acme.json - --certificatesresolvers.leresolver.acme.tlschallenge=true ports : - '80:80' - '443:443' - '27017:27017' volumes : - \"./acme.json:/acme.json\" - \"/var/run/docker.sock:/var/run/docker.sock:ro\" Here we are defining two volumes for the container. \"./acme.json:/acme.json\" mounts our ACME certificate file to /acme.json in the container, which is where we've told traefik to look for it \"/var/run/docker.sock:/var/run/docker.sock:ro\" mounts our host machine's docker socket read-only inside the container Mounting the docker socket in the container allows traefik to find out which containers it needs to connect to and what traffic to route to them. Next we need to set some labels on the container, which will be used to configure some additional features: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # docker-compose.yml version : '3.3' services : reverse-proxy : image : traefik:v2.0 container_name : reverse-proxy hostname : reverse-proxy restart : always command : - --providers.docker - --entrypoints.web.address=:80 - --entrypoints.websecure.address=:443 - --entrypoints.mongodb.address=:27017 - --certificatesresolvers.leresolver.acme.caserver=https://acme-v02.api.letsencrypt.org/directory - --certificatesresolvers.leresolver.acme.email=<youremail@yourdomain.tld> - --certificatesresolvers.leresolver.acme.storage=/acme.json - --certificatesresolvers.leresolver.acme.tlschallenge=true ports : - '80:80' - '443:443' - '27017:27017' volumes : - \"./acme.json:/acme.json\" - \"/var/run/docker.sock:/var/run/docker.sock:ro\" labels : - traefik.http.middlewares.compress.compress=true - traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https - traefik.http.routers.redirs.rule=hostregexp(`{host:.+}`) - traefik.http.routers.redirs.entrypoints=web - traefik.http.routers.redirs.middlewares=redirect-to-https traefik.http.middlewares.compress.compress=true creates a new traefik middleware called compress that compresses traffic traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https creates a middleware that redirects traffic to HTTPS traefik.http.routers.redirs.rule=hostregexp(`{host:.+}`) creates a router that matches to all domains traefik.http.routers.redirs.entrypoints=web sets the router to listen on the HTTP web entrypoint traefik.http.routers.redirs.middlewares=redirect-to-https enables the HTTPS redirection middleware Essentially, these labels enable compression on web traffic and automatically redirect any HTTP traffic to HTTPS. Finally, we can add our docker network: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 # docker-compose.yml version : '3.3' services : reverse-proxy : image : traefik:v2.0 container_name : reverse-proxy hostname : reverse-proxy restart : always command : - --providers.docker - --entrypoints.web.address=:80 - --entrypoints.websecure.address=:443 - --entrypoints.mongodb.address=:27017 - --certificatesresolvers.leresolver.acme.caserver=https://acme-v02.api.letsencrypt.org/directory - --certificatesresolvers.leresolver.acme.email=<youremail@yourdomain.tld> - --certificatesresolvers.leresolver.acme.storage=/acme.json - --certificatesresolvers.leresolver.acme.tlschallenge=true ports : - '80:80' - '443:443' - '27017:27017' volumes : - \"./acme.json:/acme.json\" - \"/var/run/docker.sock:/var/run/docker.sock:ro\" labels : - traefik.http.middlewares.compress.compress=true - traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https - traefik.http.routers.redirs.rule=hostregexp(`{host:.+}`) - traefik.http.routers.redirs.entrypoints=web - traefik.http.routers.redirs.middlewares=redirect-to-https networks : - strangescout_main networks : strangescout_main : external : true There are two parts to adding the network. First, we tell our reverse-proxy service to attach to the strangescout_main network, then we define the network in the top level of the compose file.","title":"Creating the compose file"},{"location":"installation-guide/#starting-the-reverse-proxy","text":"To start the reverse proxy you only need to run one command: 1 docker-compose up -d As long as you're in the same directory as the docker-compose.yml file, it will automatically be read and the service will start up and fork to the background thanks to the -d flag!","title":"Starting the reverse proxy"},{"location":"scouter-guide/","text":"","title":"Scouter Guide"},{"location":"strangescout-api/authentication-routes/","text":"These API routes are used for user authentication (creating accounts, logging in, and deleting accounts) Create User \u00b6 Creates a new user account Properties \u00b6 Restricted endpoint?: No URL /api/users Method POST URL Params None Data Params Name Type Required Description Example email string required email of the new user bobjones@mydomain.com password string required password of the new user supersecret code string required 8 character alphanumeric invite code A1b2C3d4 Example Payload \u00b6 1 2 3 4 5 { \"email\" : \"bobjones@mydomain.com\" , \"password\" : \"supersecret\" , \"code\" : \"A1b2C3d4\" } Successful Response \u00b6 Response Code 200 Response Body Name Type Description Example _id string MongoDB object id 507f191e810c19729de860ea email string email of the user bobjones@mydomain.com admin boolean is the user an admin true invite boolean can the user invite new users true token string the user's authorization token (JWT) ... Example: 1 2 3 4 5 6 7 { \"_id\" : \"507f191e810c19729de860ea\" , \"email\" : \"bobjones@mydomain.com\" , \"admin\" : true , \"invite\" : true , \"token\" : \"eyJhbGciOiJIUzI1NiJ9.eyJkYXRhIjp0cnVlfQ.v9y-_MKlFV_Dq4j7cDpyJMwNU6cJbd9bbdMbxwWs-GI\" } Failed Responses \u00b6 Response Code 403 Reason The invite code cannot be used for this email Response Code 409 Reason Username already exists Response Code 422 Reason Email, password, or code is either not given or invalid Response Code 440 Reason The invite code is expired Note expired invite codes are deleted after attempted use, so this response will only appear the first time a code is attempted to be used after it expires Login User \u00b6 Logs in to an account Properties \u00b6 Restricted endpoint?: No URL /api/users/session Method POST URL Params None Data Params Name Type Required Description Example email string required email of the user bobjones@mydomain.com password string required password of the user supersecret Example Payload \u00b6 1 2 3 4 { \"email\" : \"bobjones@mydomain.com\" , \"password\" : \"supersecret\" } Successful Response \u00b6 Response Code 200 Response Body Name Type Description Example _id string MongoDB object id 507f191e810c19729de860ea email string email of the user bobjones@mydomain.com admin boolean is the user an admin true invite boolean can the user invite new users true token string the user's authorization token (JWT) ... Example: 1 2 3 4 5 6 7 { \"_id\" : \"507f191e810c19729de860ea\" , \"email\" : \"bobjones@mydomain.com\" , \"admin\" : true , \"invite\" : true , \"token\" : \"eyJhbGciOiJIUzI1NiJ9.eyJkYXRhIjp0cnVlfQ.v9y-_MKlFV_Dq4j7cDpyJMwNU6cJbd9bbdMbxwWs-GI\" } Failed Responses \u00b6 Response Code 422 Reason Valid email or password not given Response Code 404 Reason User not found Verify User Token \u00b6 Verifies a session token Properties \u00b6 Restricted endpoint?: Yes URL /api/users/session Method GET Headers Authorization : Token <user_token_here> URL Params None Data Params None Successful Response \u00b6 Response Code 200 Response Body Name Type Description Example _id string MongoDB object id 507f191e810c19729de860ea email string email of the user bobjones@mydomain.com admin boolean is the user an admin true invite boolean can the user invite new users true token string the user's authorization token (JWT) ... Example: 1 2 3 4 5 6 7 { \"_id\" : \"507f191e810c19729de860ea\" , \"email\" : \"bobjones@mydomain.com\" , \"admin\" : true , \"invite\" : true , \"token\" : \"eyJhbGciOiJIUzI1NiJ9.eyJkYXRhIjp0cnVlfQ.v9y-_MKlFV_Dq4j7cDpyJMwNU6cJbd9bbdMbxwWs-GI\" } Failed Responses \u00b6 Response Code 404 Reason User not found","title":"Authentication Routes"},{"location":"strangescout-api/authentication-routes/#create-user","text":"Creates a new user account","title":"Create User"},{"location":"strangescout-api/authentication-routes/#properties","text":"Restricted endpoint?: No URL /api/users Method POST URL Params None Data Params Name Type Required Description Example email string required email of the new user bobjones@mydomain.com password string required password of the new user supersecret code string required 8 character alphanumeric invite code A1b2C3d4","title":"Properties"},{"location":"strangescout-api/authentication-routes/#example-payload","text":"1 2 3 4 5 { \"email\" : \"bobjones@mydomain.com\" , \"password\" : \"supersecret\" , \"code\" : \"A1b2C3d4\" }","title":"Example Payload"},{"location":"strangescout-api/authentication-routes/#successful-response","text":"Response Code 200 Response Body Name Type Description Example _id string MongoDB object id 507f191e810c19729de860ea email string email of the user bobjones@mydomain.com admin boolean is the user an admin true invite boolean can the user invite new users true token string the user's authorization token (JWT) ... Example: 1 2 3 4 5 6 7 { \"_id\" : \"507f191e810c19729de860ea\" , \"email\" : \"bobjones@mydomain.com\" , \"admin\" : true , \"invite\" : true , \"token\" : \"eyJhbGciOiJIUzI1NiJ9.eyJkYXRhIjp0cnVlfQ.v9y-_MKlFV_Dq4j7cDpyJMwNU6cJbd9bbdMbxwWs-GI\" }","title":"Successful Response"},{"location":"strangescout-api/authentication-routes/#failed-responses","text":"Response Code 403 Reason The invite code cannot be used for this email Response Code 409 Reason Username already exists Response Code 422 Reason Email, password, or code is either not given or invalid Response Code 440 Reason The invite code is expired Note expired invite codes are deleted after attempted use, so this response will only appear the first time a code is attempted to be used after it expires","title":"Failed Responses"},{"location":"strangescout-api/authentication-routes/#login-user","text":"Logs in to an account","title":"Login User"},{"location":"strangescout-api/authentication-routes/#properties_1","text":"Restricted endpoint?: No URL /api/users/session Method POST URL Params None Data Params Name Type Required Description Example email string required email of the user bobjones@mydomain.com password string required password of the user supersecret","title":"Properties"},{"location":"strangescout-api/authentication-routes/#example-payload_1","text":"1 2 3 4 { \"email\" : \"bobjones@mydomain.com\" , \"password\" : \"supersecret\" }","title":"Example Payload"},{"location":"strangescout-api/authentication-routes/#successful-response_1","text":"Response Code 200 Response Body Name Type Description Example _id string MongoDB object id 507f191e810c19729de860ea email string email of the user bobjones@mydomain.com admin boolean is the user an admin true invite boolean can the user invite new users true token string the user's authorization token (JWT) ... Example: 1 2 3 4 5 6 7 { \"_id\" : \"507f191e810c19729de860ea\" , \"email\" : \"bobjones@mydomain.com\" , \"admin\" : true , \"invite\" : true , \"token\" : \"eyJhbGciOiJIUzI1NiJ9.eyJkYXRhIjp0cnVlfQ.v9y-_MKlFV_Dq4j7cDpyJMwNU6cJbd9bbdMbxwWs-GI\" }","title":"Successful Response"},{"location":"strangescout-api/authentication-routes/#failed-responses_1","text":"Response Code 422 Reason Valid email or password not given Response Code 404 Reason User not found","title":"Failed Responses"},{"location":"strangescout-api/authentication-routes/#verify-user-token","text":"Verifies a session token","title":"Verify User Token"},{"location":"strangescout-api/authentication-routes/#properties_2","text":"Restricted endpoint?: Yes URL /api/users/session Method GET Headers Authorization : Token <user_token_here> URL Params None Data Params None","title":"Properties"},{"location":"strangescout-api/authentication-routes/#successful-response_2","text":"Response Code 200 Response Body Name Type Description Example _id string MongoDB object id 507f191e810c19729de860ea email string email of the user bobjones@mydomain.com admin boolean is the user an admin true invite boolean can the user invite new users true token string the user's authorization token (JWT) ... Example: 1 2 3 4 5 6 7 { \"_id\" : \"507f191e810c19729de860ea\" , \"email\" : \"bobjones@mydomain.com\" , \"admin\" : true , \"invite\" : true , \"token\" : \"eyJhbGciOiJIUzI1NiJ9.eyJkYXRhIjp0cnVlfQ.v9y-_MKlFV_Dq4j7cDpyJMwNU6cJbd9bbdMbxwWs-GI\" }","title":"Successful Response"},{"location":"strangescout-api/authentication-routes/#failed-responses_2","text":"Response Code 404 Reason User not found","title":"Failed Responses"}]}